(() => {
  // helpers.js
  var html = String.raw;
  var css = (string, ...subs) => {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(String.raw(string, subs));
    return sheet;
  };

  // stateset.js
  var StateSet2 = class extends Set {
    #el = null;
    #existing = null;
    constructor(el, existing) {
      super();
      this.#el = el;
      this.#existing = existing;
    }
    add(state) {
      super.add(state);
      const existing = this.#existing;
      if (existing) {
        try {
          existing.add(state);
        } catch {
          existing.add(`--${state}`);
        }
      } else {
        this.#el.setAttribute(`state-${state}`, "");
      }
    }
    delete(state) {
      super.delete(state);
      const existing = this.#existing;
      if (existing) {
        existing.delete(state);
        existing.delete(`--${state}`);
      } else {
        this.#el.removeAttribute(`state-${state}`);
      }
    }
    has(state) {
      return super.has(state);
    }
    clear() {
      for (const state of this)
        this.delete(state);
    }
  };
  var replaceSync = CSSStyleSheet.prototype.replaceSync;
  Object.defineProperty(CSSStyleSheet.prototype, "replaceSync", {
    value: function(text) {
      text = text.replace(/:state\(([^\)]+)\)/g, ":where(:state($1), :--$1, [state-$1])");
      replaceSync.call(this, text);
    }
  });

  // fdgt-element.js
  var globalStyles = css`
  :root, :host {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    font-size: 14px;
    --fdgt-bg-1: #39393b;
    --fdgt-bg-2: #2d2d2f;
    --fdgt-bg-3: #505050;
    --fdgt-bg-4: #626262;
    --fdgt-br-1: #232325;
    --fdgt-sh-1: #2e2e30;
    --fdgt-sh-2: #aaaaaa;
    --fdgt-ac-1: #2093fe;
    --fdgt-ac-danger: #e95e3d;
    --fdgt-fg-1: #a2a2aa;
    --fdgt-radius-1: 3px;
    --fdgt-radius-2: 6px;
    --fdgt-focus-ring: 2px solid var(--fdgt-ac-1);
  }

  :host {
    display: flex;
    flex: 1;
  }
`;
  var FidgetElement = class extends HTMLElement {
    #abortController = new AbortController();
    get signal() {
      return this.#abortController.signal;
    }
    constructor(template8, styles9, rootOptions = {}) {
      super();
      if (!this.shadowRoot)
        this.attachShadow({ mode: "open", ...rootOptions || {} });
      this.shadowRoot.innerHTML ||= template8;
      this.shadowRoot.adoptedStyleSheets.push(globalStyles);
      this.shadowRoot.adoptedStyleSheets.push(styles9);
    }
    attachInternals() {
      const internals = super.attachInternals();
      Object.defineProperty(internals, "states", { value: new StateSet2(this, internals.states) });
      return internals;
    }
    connectedCallback() {
      this.#abortController?.abort();
      this.#abortController = new AbortController();
      if (this.name) {
        this.dispatchEvent(new Event("request-value", { bubbles: true }));
      }
    }
    disconnectedCallback() {
      this.#abortController?.abort();
    }
    get name() {
      return this.getAttribute("name");
    }
  };

  // fdgt-icon.js
  var styles = css`
  :host {
    width: 16px;
    height: 16px;
    aspect-ratio: 1/1;
    align-items: center;
    flex: initial;
  }

  svg {
    width: 100%;
    height: 100%;
  }

  :host(:not([name])), svg { display: none }
  :host([name=close]) [name=close] { display: block }
  :host([name=more]) [name=more] { display: block }
  :host([name=chevron-left]) [name=chevron-left] { display: block }
  :host([name=chevron-down]) [name=chevron-down] { display: block }
  :host([name=grip]) [name=grip] { display: block }
  :host([name=move]) [name=move] { display: block }
`;
  var template = html`
  <svg role="presentation" name="close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
  <svg role="presentation" name="more" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
  <svg role="presentation" name="chevron-left" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
  <svg role="presentation" name="chevron-down" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
  <svg role="presentation" name="grip" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="12" r="1"/><circle cx="9" cy="5" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="19" r="1"/></svg>
  <svg role="presentation" name="move" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></svg>
`;
  customElements.define("fdgt-icon", class extends FidgetElement {
    #internals = this.attachInternals();
    constructor() {
      super(template, styles);
      this.#internals.role = this.role == "presentation" ? "presentation" : "image";
    }
    set name(value) {
      this.setAttribute("name", value);
    }
  });

  // fdgt-button.js
  var styles2 = css`
  :host {
    margin: 3px;
  }

  button {
    display: flex;
    width: max-content;
    align-items: center;
    border-radius: var(--fdgt-button-radius, var(--fdgt-radius-1));
    margin: 0;
    color: var(--fdgt-button-fg, var(--fdgt-fg-1));
    min-height: 35px;
    min-width: 30px;
    flex: 1;
    background: var(--fdgt-button-bg, var(--fdgt-bg-2));
    border: 1px solid var(--fdgt-button-br, var(--fdgt-br-1));
    box-shadow: 0 1px 1px var(--fdgt-button-sh, var(--fdgt-sh-1));
    padding: 0 8px;
  }

  [name=label] {
    display: block;
    flex: 1;
    text-align: left;
  }

  :host([variant=text]) button {
    background: none;
    border: 1px solid transparent;
    box-shadow: none;
  }

  button:hover {
    background: var(--fdgt-button-hover-br, var(--fdgt-bg-3));
  }

  :host([variant=text]) button:hover {
    background: var(--fdgt-button-text-hover-br, var(--fdgt-bg-4));
  }

  button:active {
    background: var(--fdgt-button-active-br, var(--fdgt-bg-1));
    box-shadow: 0 0 3px var(--fdgt-button-active-sh, var(--fdgt-sh-1)) inset;
  }

  button:focus-visible {
    outline: var(--fdgt-focus-ring);
  }

  [part=lead-icon] {
    padding-right: 5px;
  }

  [part=trail-icon] {
    padding-left: 5px;
  }
`;
  var template2 = html`
  <button part="button">
    <fdgt-icon part="lead-icon"></fdgt-icon>
    <slot name="label"></slot>
    <fdgt-icon part="trail-icon"></fdgt-icon>
  </button>
`;
  customElements.define("fdgt-button", class extends FidgetElement {
    static observedAttributes = ["label", "lead-icon", "trail-icon"];
    #internals = this.attachInternals();
    constructor() {
      super(template2, styles2, { delegatesFocus: true });
      this.shadowRoot.addEventListener("click", this);
    }
    attributeChangedCallback(name, old, value) {
      if (!this.shadowRoot)
        return;
      if (name === "label") {
        this.shadowRoot.querySelector("slot[name=label]").textContent = this.getAttribute("label");
      } else if (name === "lead-icon") {
        if (value) {
          this.shadowRoot.querySelector("[part=lead-icon]").setAttribute("name", value);
        } else {
          this.shadowRoot.querySelector("[part=lead-icon]").removeAttribute("name");
        }
      } else if (name == "trail-icon") {
        if (value) {
          this.shadowRoot.querySelector("[part=trail-icon]").setAttribute("name", value);
        } else {
          this.shadowRoot.querySelector("[part=trail-icon]").removeAttribute("name");
        }
      }
    }
    handleEvent(event) {
      if (event.type == "click")
        this.commit();
    }
    commit() {
      const el = this.closest("fdgt-control")?.for;
      const method = this.getAttribute("call");
      if (el && method && method in el) {
        el[method]();
      }
    }
  });

  // fdgt-menu.js
  var styles3 = css`
  :host {
    margin: 3px;
    position: relative;
    --fdgt-menu-offset-pos: 7px;
  }

  fdgt-button::part(trail-icon) {
    width: 16px;
    transition: rotate 100ms;
    transform-origin: 13px;
  }

  [part=button] {
    margin: 0;
  }

  [part=menu] {
    display: none;
    padding: 2px;
    flex-direction: column;
    position: fixed;
    inset: calc(var(--top, 0px) + var(--fdgt-menu-offset-pos)) auto auto var(--left, 0px);
    border-radius: 3px;
    border: 1px solid transparent;
    box-shadow: 0 0 8px var(--fdgt-menu-popup-sh, var(--fdgt-sh-2));
    background: var(--fdgt-menu-popup-bg, var(--fdgt-bg-3));
    min-width: 100px;
    color: var(--fdgt-menu-popup-fg, var(--fdgt-fg-1));
  }

  :host(:state(open)) [part=menu] {
    display: flex;
  }

  :host(:state(open)) button, button:active {
    background: var(--fdgt-menu-button-active-br, var(--fdgt-bg-1));
    box-shadow: 0 0 3px var(--fdgt-menu-button-active-sh, var(--fdgt-sh-1)) inset;
  }

  :host(:state(open):is(:not([trail-icon]), [trail-icon=chevron-down])) fdgt-button::part(trail-icon) {
    rotate: 180deg;
  }

  :host(:not([label])[trail-icon]) fdgt-button::part(trail-icon) {
    padding: 0;
  }

  :host [part=menu]:not(:where(:popover-open)) {
    inset: calc(35px + var(--fdgt-menu-offset-pos)) auto auto 0;
  }
`;
  var template3 = html`
  <fdgt-button part="button" trail-icon="chevron-down">
    <slot name="label" slot="label"></slot>
  </fdgt-button>
  <div popover="manual" part="menu">
    <slot></slot>
  </div>
`;
  customElements.define("fdgt-menu", class extends FidgetElement {
    static observedAttributes = ["lead-icon", "label", "trail-icon"];
    #internals = this.attachInternals();
    #states = this.#internals.states || new StateSet(this);
    constructor() {
      super(template3, styles3);
      this.shadowRoot.addEventListener("click", this);
    }
    connectedCallback() {
      super.connectedCallback();
      const { signal } = this;
      window.addEventListener("keydown", this, { signal });
      window.addEventListener("pointerdown", this, { signal });
    }
    attributeChangedCallback(name, old, value) {
      if (name === "label") {
        this.shadowRoot.querySelector("slot[name=label]").textContent = value;
      } else if (name === "lead-icon") {
        this.shadowRoot.querySelector("fdgt-button").setAttribute("lead-icon", value);
      } else if (name === "trail-icon") {
        this.shadowRoot.querySelector("fdgt-button").setAttribute("trail-icon", value);
      }
    }
    handleEvent(event) {
      if (event.type == "keydown" && event.code === "Escape") {
        this.close();
      }
      if (event.type == "pointerdown" && !event.composedPath().includes(this)) {
        this.close();
      }
      if (event.type == "click" && event.composedPath().includes(this.shadowRoot.querySelector("[part=button]"))) {
        if (this.#states.has("open")) {
          this.close();
        } else {
          this.open();
        }
      }
    }
    open() {
      const menu = this.shadowRoot.querySelector("[part=menu]");
      const rect = this.getBoundingClientRect();
      menu.style.setProperty("--top", `${rect.bottom}px`, "important");
      menu.style.setProperty("--left", `${rect.left}px`, "important");
      this.#states.add("open");
      menu.showPopover?.();
    }
    close() {
      this.shadowRoot.querySelector("[part=menu]").hidePopover?.();
      this.#states.delete("open");
    }
  });

  // fdgt-switch.js
  var styles4 = css`
  :host {
    margin: 3px 6px;
    min-height: 35px;
  }
  label {
    display: flex;
    flex-direction: row;
    align-items: center;
  }
  label:focus-visible {
    border-radius: var(--fdgt-switch-radius, var(--fdgt-radius-1));
    outline: var(--fdgt-focus-ring);
  }
  [part=track] {
    display: flex;
    align-items: center;
    width: 40px;
    height: 20px;
    margin: 0 0 0 6px;
    background: var(--fdgt-switch-track-bg, var(--fdgt-ac-1));
    border-radius: 20px;
    box-shadow: 0 0 3px var(--fdgt-switch-track-sh, var(--fdgt-sh-1)) inset;
    transition: color 100ms ease-in-out;
  }
  [part=thumb] {
    display: flex;
    align-items: center;
    height: 25px;
    width: 25px;
    background: var(--fdgt-switch-bg, var(--fdgt-bg-2));
    border-radius: 100%;
    border: 1px solid var(--fdgt-switch-br, var(--fdgt-br-1));
    box-shadow: 0 1px 1px var(--fdgt-switch-sh, var(--fdgt-sh-1));
    color: var(--fdgt-switch-fg, var(--fdgt-fg-1));
    transition: transform 100ms ease-in-out;
  }
  [part=track]:hover [part=thumb] {
    background: var(--fdgt-switch-thumb-hover-br, var(--fdgt-bg-3));
  }
  :host(:not(:where(:state(on),:--on,[state-on]))) [part=track] {
    background: var(--fdgt-switch-track-off-bg, var(--fdgt-ac-danger));
  }
  :host(:where(:state(on),:--on,[state-on])) [part=thumb] {
    transform: translateX(15px);
  }
`;
  var template4 = html`
  <label tabindex=0>
    <slot name="label"></slot>
    <div part="track">
      <div part="thumb">
      </div>
    </div>
  </label>
`;
  customElements.define("fdgt-switch", class extends FidgetElement {
    static observedAttributes = ["label"];
    #internals = this.attachInternals();
    #states = this.#internals.states || new StateSet(this);
    constructor() {
      super(template4, styles4, { delegatesFocus: true });
      this.#internals.role = "switch";
      this.#internals.ariaChecked = "false";
      this.shadowRoot.addEventListener("click", this);
      this.shadowRoot.addEventListener("keydown", this);
    }
    attributeChangedCallback(name) {
      if (this.shadowRoot && name === "label") {
        this.shadowRoot.querySelector("slot[name=label]").textContent = this.getAttribute("label");
      }
    }
    handleEvent(event) {
      if (event.type == "click")
        this.toggle(event);
      if (event.type == "keydown" && (event.code == "Space" || event.code == "Enter"))
        this.toggle(event);
    }
    get value() {
      return this.#states.has("on");
    }
    toggle(event) {
      if (this.#states.has("on")) {
        this.#states.ariaChecked = "true";
        this.#states.delete("on");
      } else {
        this.#states.ariaChecked = "false";
        this.#states.add("on");
      }
      this.dispatchEvent(new Event("change", { bubbles: true }));
    }
  });

  // fdgt-sep.js
  var styles5 = css`
  :host {
    display: block;
    width: 0px !important;
    flex: 0;
    border-left: 1px solid var(--fdgt-control-sep-br, var(--fdgt-br-1));
    border-right: 1px solid var(--fdgt-control-sep-sh, var(--fdgt-sh-1));
    margin: 0 4px;
  }
`;
  customElements.define("fdgt-sep", class extends FidgetElement {
    #internals = this.attachInternals();
    constructor() {
      super("", styles5);
      this.#internals.role = "presentation";
    }
  });

  // fdgt-control.js
  var styles6 = css`
  :host {
    --xc: clamp(0px, calc(var(--left, 25px) - var(--offset-x, 0px)), calc(100vw - var(--width, 20px))) !important;
    --yc: max(0px, calc(var(--top, 25px) - var(--offset-y, 0px))) !important;
    position: absolute;
    display: flex;
    border: 1px solid var(--fdgt-control-br, var(--border-1));
    background: var(--figdet-control-bg, var(--fdgt-bg-1));
    color: var(--fdgt-control-fg, var(--fdgt-fg-1));
    box-shadow: 0px 0px 8px var(--fdgt-control-sh, var(--fdgt-sh-2));
    border-radius: 3px;
    margin: 0;
    padding: 0;
    transform: translate3d(var(--xc), var(--yc), 0);
    transition: width 100ms ease-in;
    width: fit-content;
    height: fit-content;
    inset: 0;
    overflow: visible;
    touch-action: none;
  }

  [part=controls] {
    display: flex;
    flex: 1;
  }

  button {
    appearance: none;
    background: none;
    border: 0;
    position: relative;
    width: 30px;
    height: 40px;
    color: inherit;
  }

  button:focus-visible {
    outline: var(--fdgt-focus-ring);
  }

  [part=grip] {
    cursor: move;
  }

  button fdgt-icon {
    vertical-align: middle;
    width: 16px;
    transition: rotate 100ms;
    transform-origin: 8px;
  }

  [part=expand] {
    margin-left: -4px;
  }

  [part=more-menu]::part(button)::part(trail-icon) {
    display: none;
  }

  :host(:state(no-overflow)) fdgt-sep {
    display: none;
  }

  :host(:state(no-overflow)) [part=expand] {
    display: none;
  }

  :host(:state(dragging)) {
    cursor: grabbing;
  }

  :host(:state(overflow)) [part=expand] fdgt-icon {
    rotate: 180deg;
  }

  :host(:not(:state(overflow))) [part=more-menu] {
    display: none;
  }

  :host(:state(reflow-nudge)) [part=expand] fdgt-icon {
    color: var(--fdgt-control-expand-nudge-fg, var(--fdgt-ac-danger));
    animation: nudge 100ms infinite ease-in-out;
  }

  :host(:state(move-nudge)) [part=grip] fdgt-icon {
    color: var(--fdgt-control-move-nudge-fg, var(--fdgt-ac-danger));
    animation: nudge 100ms infinite ease-in-out;
  }

  @keyframes nudge {
    0% {
      translate: 0;
    }
    25% {
      translate: -2px;
    }
    75% {
      translate: 2px;
    }
  }
`;
  var template5 = html`
  <button type="button" part="grip" aria-pressed="false" aria-label="Move toolbar">
    <fdgt-icon name="grip" role="presentation"></fdgt-icon>
  </button>
  <slot part="controls"></slot>
  <fdgt-menu aria-label="More" part="more-menu" trail-icon="more">
    <slot part="more"></slot>
  </fdgt-menu>
  <fdgt-sep></fdgt-sep>
  <button type="button" part="expand" aria-pressed="false" aria-label="Expand">
    <fdgt-icon name="chevron-left" role="presentation"></fdgt-icon>
  </button>
`;
  customElements.define("fdgt-control", class extends FidgetElement {
    static observedAttributes = ["top", "left"];
    #internals = this.attachInternals();
    #states = this.#internals.states || new StateSet(this);
    #observer = new MutationObserver(() => this.#reflow());
    #sheet = css`
    :host {
      --top: 0px;
      --left: 0px;
      --width: 0px;
      --offset-x: 0px;
      --offset-y: 0px;
    }
  `;
    get #style() {
      return this.#sheet.rules[0].style;
    }
    constructor() {
      super(template5, styles6, { slotAssignment: "manual" });
      this.shadowRoot.addEventListener("pointerdown", this);
      this.shadowRoot.addEventListener("pointerenter", this);
      this.shadowRoot.addEventListener("click", this);
      this.shadowRoot.addEventListener("keydown", this);
      this.addEventListener("request-value", this);
      this.addEventListener("change", this);
      this.#internals.role = "dialog";
      this.#internals.ariaLabel = "Developer controls";
      this.style.setProperty("--this-variable-is-for-webkit-style-invalidation-bugs", "1px");
    }
    get for() {
      return this.ownerDocument.getElementById(this.getAttribute("for") || "");
    }
    connectedCallback() {
      super.connectedCallback();
      const { signal } = this;
      if (this.showPopover) {
        this.popover = "manual";
        this.showPopover();
      }
      this.#observer.observe(this, { childList: true });
      signal.addEventListener("abort", () => this.#observer.unobserve(this));
      this.shadowRoot.adoptedStyleSheets.push(this.#sheet);
      if (!this.hasAttribute("top") && !this.hasAttribute("left")) {
        requestAnimationFrame(() => {
          if (!this.for)
            return;
          const rect = this.getBoundingClientRect();
          const forRect = this.for.getBoundingClientRect();
          const marginLeft = getComputedStyle(this.for).getPropertyValue("margin-left");
          const marginRight = getComputedStyle(this.for).getPropertyValue("margin-right");
          const doc = this.ownerDocument.documentElement;
          this.#style.setProperty("--offset-x", `-${doc.scrollLeft}px`, "important");
          this.#style.setProperty("--offset-y", `-${doc.scrollTop}px`, "important");
          this.#style.setProperty("--top", forRect.top - rect.height / 2 + forRect.height / 2 + "px", "important");
          this.#style.setProperty("--left", `calc(${forRect.right + 10}px + ${marginRight})`, "important");
          this.#style.setProperty("--width", rect.width + "px", "important");
        });
      }
      this.#reflow();
    }
    handleEvent(event) {
      if (event.type == "pointerdown") {
        this.#startDrag(event);
      } else if (event.type == "ponterenter" && this.showPopover) {
        this.hidePopover();
        this.showPopover();
      } else if (event.type == "pointermove" && this.#states.has("dragging")) {
        this.#move(event);
      } else if (event.type == "keydown" && event.target.closest("[part=grip]")) {
        this.#handleGripKey(event);
      }
      if (event.type == "click" && event.target.closest("[part=expand]")) {
        if (!this.#states.has("overflow")) {
          this.collapse();
        } else if (!this.#reflow()) {
          this.#states.add("reflow-nudge");
          setTimeout(() => this.#states.delete("reflow-nudge"), 200);
          this.shadowRoot.querySelector("[part=more-menu]").open();
        }
      } else if (event.type === "change") {
        this.#handleChange(event);
      } else if (event.type === "request-value") {
        this.#handleRequestValue(event);
      }
    }
    attributeChangedCallback(name, old, value) {
      if (name === "top") {
        if (!Number.isNaN(Number(value)))
          value += "px";
        this.#style.setProperty("--top", value, "important");
      } else if (name === "left") {
        if (!Number.isNaN(Number(value)))
          value += "px";
        this.#style.setProperty("--left", value, "important");
      }
    }
    #handleGripKey(event) {
      const grip = this.shadowRoot.querySelector("[part=grip]");
      if (event.code == "Enter" || event.code == "Space") {
        grip.setAttribute("aria-pressed", "true");
        grip.querySelector("fdgt-icon").setAttribute("name", "move");
        grip.addEventListener("focusout", () => {
          grip.setAttribute("aria-pressed", "false");
          grip.querySelector("fdgt-icon").setAttribute("name", "grip");
        });
        return;
      }
      if (grip.getAttribute("aria-pressed") !== "true")
        return;
      if (event.code == "Escape" || event.code == "Enter" || event.code == "Space" || event.code == "Tab") {
        grip.setAttribute("aria-pressed", "false");
        grip.querySelector("fdgt-icon").setAttribute("name", "grip");
        return;
      }
      let clientX = parseInt(getComputedStyle(this).getPropertyValue("--left")) || 0;
      let clientY = parseInt(getComputedStyle(this).getPropertyValue("--top")) || 0;
      if (event.code == "ArrowRight")
        clientX += 20;
      else if (event.code == "ArrowLeft")
        clientX -= 20;
      else if (event.code == "ArrowUp")
        clientY -= 20;
      else if (event.code == "ArrowDown")
        clientY += 20;
      clientX = Math.max(clientX, 0);
      clientY = Math.max(clientY, 0);
      if (!this.#move({ clientX, clientY })) {
        this.#states.add("move-nudge");
        setTimeout(() => this.#states.delete("move-nudge"), 200);
      }
      event.preventDefault();
    }
    #startDrag(event) {
      if (event.buttons !== 1 || !event.target.closest("[part=grip]"))
        return;
      this.#states.add("dragging");
      this.setPointerCapture(event.pointerId);
      this.addEventListener("pointermove", this);
      const rect = this.getBoundingClientRect();
      this.#style.setProperty("--width", `${rect.width}px`, "important");
      const doc = this.ownerDocument.documentElement;
      this.#style.setProperty("--offset-x", `${event.clientX - rect.left - doc.scrollLeft}px`, "important");
      this.#style.setProperty("--offset-y", `${event.clientY - rect.top - doc.scrollTop}px`, "important");
      window.addEventListener("pointerup", () => this.#endDrag(), { once: true });
      this.#move(event);
    }
    #move({ clientY, clientX }) {
      let rect = this.getBoundingClientRect();
      let pos = rect.x + rect.y;
      this.#style.setProperty("--left", `${clientX}px`, "important");
      this.#style.setProperty("--top", `${clientY}px`, "important");
      rect = this.getBoundingClientRect();
      if (rect.right + 10 >= window.innerWidth) {
        this.#reflow();
      }
      return pos != rect.x + rect.y;
    }
    #endDrag() {
      this.removeEventListener("pointermove", this);
      this.#states.delete("dragging");
    }
    #reflow() {
      if (!this.shadowRoot)
        return;
      const controls = this.shadowRoot.querySelector("slot[part=controls]");
      if (this.children.length === 1) {
        controls.assign(...this.children);
        this.#states.add("no-overflow");
        return;
      } else {
        this.#states.delete("no-overflow");
      }
      const moreSlot = this.shadowRoot.querySelector("slot[part=more]");
      let len = moreSlot.assignedNodes().length;
      controls.assign();
      const rect = this.getBoundingClientRect();
      let allowableWidth = window.innerWidth - rect.left - rect.width;
      let didOverflow = false;
      if (allowableWidth > 10) {
        let mainflow = [];
        let overflow = [];
        for (const el of this.children) {
          if (!overflow.length) {
            mainflow.push(el);
            controls.assign(...mainflow);
            if (controls.getBoundingClientRect().width >= allowableWidth) {
              overflow.push(mainflow.pop());
            }
          } else {
            overflow.push(el);
          }
        }
        didOverflow = overflow.length > 0;
        moreSlot.assign(...overflow);
      } else {
        didOverflow = true;
        moreSlot.assign(...this.children);
      }
      this.#style.setProperty("--width", `${this.getBoundingClientRect().width}px`, "important");
      if (didOverflow) {
        this.#states.add("overflow");
      } else {
        this.#states.delete("overflow");
      }
      return len != moreSlot.assignedNodes().length;
    }
    #handleChange(event) {
      const el = event.target;
      if (el.tagName.startsWith("FDGT-")) {
        const name = el.name;
        const value = el.value;
        if (!name)
          return;
        if (name in this.for) {
          this.for[name] = value;
        } else if (typeof value === "boolean") {
          this.for.toggleAttribute(name, value);
        } else {
          this.for.setAttribute(name, value);
        }
      }
    }
    #handleRequestValue(event) {
      const el = event.target;
      if (el.tagName.startsWith("FDGT-")) {
        const name = el.name;
        if (!name)
          return;
        if (typeof this.for[name] === "boolean") {
          el.value = this.for[name];
        } else {
          const value = this.for.getAttribute(name);
          if (value == name || value == "") {
            el.value = true;
          } else if (!this.for.hasAttribute(name)) {
            el.value = false;
          } else {
            el.value = this.for.getAttribute(name);
          }
        }
      }
    }
    collapse() {
      this.shadowRoot.querySelector("slot[part=more]").assign(...this.children);
      this.#style.setProperty("--width", `${this.getBoundingClientRect().width}px`, "important");
      this.#states.add("overflow");
    }
  });

  // fdgt-select.js
  var styles7 = css`
`;
  var template6 = html`
  <fdgt-menu>
    <span slot="label">
      <slot name="label"></slot>
      <slot name="selected-value"></slot>
    </span>
  </fdgt-menu>
`;
  customElements.define("fdgt-select", class extends FidgetElement {
    static observedAttributes = ["lead-icon", "label"];
    #internals = this.attachInternals();
    #states = this.#internals.states || new StateSet(this);
    #observer = new MutationObserver(() => this.#build());
    #value = null;
    get value() {
      return this.#value;
    }
    set value(value) {
      this.#value = value;
      for (const option of this.querySelector("datalist")?.querySelectorAll("option") || []) {
        if (option.value == value) {
          const selectedValueSlot = this.shadowRoot.querySelector('[name="selected-value"]');
          selectedValueSlot.textContent = `: ${option.textContent}`;
          this.shadowRoot.querySelector("fdgt-menu").close();
          this.dispatchEvent(new Event("change", { bubbles: true }));
          break;
        }
      }
    }
    constructor() {
      super(template6, styles7);
    }
    connectedCallback() {
      super.connectedCallback();
      this.#observer.observe(this, { childList: true });
      this.shadowRoot.addEventListener("click", this);
      this.#build();
    }
    attributeChangedCallback(name, old, value) {
      if (name === "label")
        this.shadowRoot.querySelector("slot[name=label]").textContent = value;
      if (name === "lead-icon")
        this.shadowRoot.querySelector("fdgt-menu").setAttribute("lead-icon", value);
    }
    handleEvent(event) {
      if (event.type === "click")
        this.#handleClick(event);
    }
    #handleClick(event) {
      const menu = this.shadowRoot.querySelector("fdgt-menu");
      const buttons = [...this.shadowRoot.querySelectorAll("fdgt-button")];
      const button = event.composedPath().find((el) => el.tagName == "FDGT-BUTTON");
      let index = buttons.indexOf(button);
      if (index >= 0 && button?.parentElement === menu) {
        const options = [...this.querySelector("datalist")?.querySelectorAll("option") || []];
        this.value = options[index]?.value;
      }
    }
    #build() {
      const children = [];
      for (const opt of this.querySelector("datalist")?.querySelectorAll("option") || []) {
        const button = document.createElement("fdgt-button");
        button.setAttribute("label", opt.textContent);
        if (opt.hasAttribute("lead-icon"))
          button.setAttribute("lead-icon", opt.getAttribute("lead-icon"));
        if (opt.hasAttribute("trail-icon"))
          button.setAttribute("trail-icon", opt.getAttribute("trail-icon"));
        button.setAttribute("variant", "text");
        children.push(button);
      }
      const menu = this.shadowRoot.querySelector("fdgt-menu");
      menu.setAttribute("label", this.getAttribute("label") || "Select");
      menu.replaceChildren(this.shadowRoot.querySelector("[slot=label]"), ...children);
    }
  });

  // fdgt-input.js
  var styles8 = css`
  :host {
    margin: 3px;
  }

  label {
    display: flex;
    align-items: center;
  }

  input {
    display: flex;
    width: 100%;
    align-items: center;
    border-radius: var(--fdgt-button-radius, var(--fdgt-radius-1));
    color: var(--fdgt-button-fg, var(--fdgt-fg-1));
    min-height: 30px;
    width: 100px;
    flex: 1;
    background: var(--fdgt-button-bg, var(--fdgt-bg-2));
    border: 1px solid var(--fdgt-button-br, var(--fdgt-br-1));
    box-shadow: 0 1px 1px var(--fdgt-button-sh, var(--fdgt-sh-1));
  }

  [name=label] {
    display: block;
    margin-right: 5px
  }

  [name=label]:empty {
    display: none;
  }

  :host([variant=text]) button {
    background: none;
    border: 1px solid transparent;
    box-shadow: none;
  }

  input:hover {
    background: var(--fdgt-button-hover-br, var(--fdgt-bg-3));
  }

  :host([variant=text]) input:hover {
    background: var(--fdgt-button-text-hover-br, var(--fdgt-bg-4));
  }

  input:focus, input:active {
    background: var(--fdgt-button-active-br, var(--fdgt-bg-1));
    box-shadow: 0 0 3px var(--fdgt-button-active-sh, var(--fdgt-sh-1)) inset;
    outline: var(--fdgt-focus-ring);
  }
`;
  var template7 = html`
  <label>
    <slot name="label"></slot>
    <fdgt-icon part="lead-icon"></fdgt-icon>
    <input part="input" type="text">
    <fdgt-icon part="trail-icon"></fdgt-icon>
  </label>
`;
  customElements.define("fdgt-input", class extends FidgetElement {
    static observedAttributes = ["label", "lead-icon", "trail-icon"];
    #value = null;
    get value() {
      return this.#value;
    }
    set value(value) {
      this.#value = value;
      this.shadowRoot.querySelector("input").value = value;
    }
    #internals = this.attachInternals();
    constructor() {
      super(template7, styles8, { delegatesFocus: true });
      this.shadowRoot.addEventListener("input", this);
    }
    attributeChangedCallback(name, old, value) {
      if (!this.shadowRoot)
        return;
      if (name === "label") {
        this.shadowRoot.querySelector("slot[name=label]").textContent = this.getAttribute("label");
      } else if (name === "lead-icon") {
        if (value) {
          this.shadowRoot.querySelector("[part=lead-icon]").setAttribute("name", value);
        } else {
          this.shadowRoot.querySelector("[part=lead-icon]").removeAttribute("name");
        }
      } else if (name == "trail-icon") {
        if (value) {
          this.shadowRoot.querySelector("[part=trail-icon]").setAttribute("name", value);
        } else {
          this.shadowRoot.querySelector("[part=trail-icon]").removeAttribute("name");
        }
      }
    }
    handleEvent(event) {
      this.value = event.target.value;
      this.dispatchEvent(new Event("change", { bubbles: true }));
    }
  });
})();
